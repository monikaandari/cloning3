/*
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.wireless.qa.mobileharness.shared.comm.message;

import com.google.common.collect.ImmutableMap;
import com.google.protobuf.ExtensionRegistry;
import com.google.protobuf.Message;
import com.google.protobuf.MessageOrBuilder;
import com.google.protobuf.TextFormat;
import com.google.protobuf.TextFormat.ParseException;
import java.util.Map;
import java.util.Objects;

/** Util for handling proto test messages. */
public class ProtoTestMessageUtil {

  private static final String NAMESPACE = "@protobuf";
  private static final String KEY_NAMESPACE = "namespace";
  private static final String KEY_MESSAGE_FULL_NAME = "message_full_name";
  private static final String KEY_TEXTPROTO = "textproto";
  private static final TextFormat.Printer PRINTER = TextFormat.printer().emittingSingleLine(true);
  private static final TextFormat.Parser PARSER =
      TextFormat.Parser.newBuilder()
          .setAllowUnknownEnumValues(true)
          .setAllowUnknownFields(true)
          .setAllowUnknownExtensions(true)
          .build();

  /** Encodes a proto message into a test message. */
  static ImmutableMap<String, String> encodeProtoTestMessage(MessageOrBuilder protoTestMessage) {
    return ImmutableMap.of(
        KEY_NAMESPACE,
        NAMESPACE,
        KEY_MESSAGE_FULL_NAME,
        protoTestMessage.getDescriptorForType().getFullName(),
        KEY_TEXTPROTO,
        PRINTER.printToString(protoTestMessage));
  }

  /**
   * Decodes a proto message from a test message if any.
   *
   * @return true if successful, false if the test message is not generated by {@link
   *     #encodeProtoTestMessage} with the same proto message type
   * @throws ParseException if the test message is generated by {@link #encodeProtoTestMessage} with
   *     the same proto message type but the textproto string format is corrupted
   */
  public static boolean decodeProtoTestMessage(
      Map<String, String> testMessage,
      Message.Builder protoBuilder,
      ExtensionRegistry extensionRegistry)
      throws ParseException {
    if (!Objects.equals(testMessage.get(KEY_NAMESPACE), NAMESPACE)) {
      return false;
    }
    if (!Objects.equals(
        testMessage.get(KEY_MESSAGE_FULL_NAME),
        protoBuilder.getDescriptorForType().getFullName())) {
      return false;
    }
    String textproto = testMessage.get(KEY_TEXTPROTO);
    if (textproto == null) {
      return false;
    }
    PARSER.merge(textproto, extensionRegistry, protoBuilder);
    return true;
  }

  private ProtoTestMessageUtil() {}
}
